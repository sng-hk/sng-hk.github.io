---
title: "전자계산기구조 - 컴퓨터의 발전, 컴퓨터의 성능"
layout: single
classes: wide
categories : ['Computer Architecture']
---

# 1. 컴퓨터의 세대별 발전

|컴퓨터의 세대|주요 소자|기억장치|특징|
|---|---|---|---|
0세대|기계적릴레이|금속기어,카드|-|
|1세대|진공관(ex.애니악 최초 컴퓨터)|자기드럼|하드웨어개발에 중점.부피,전력多|
|2세대|트랜지스터|자기코어|고급언어 등장|
|3세대|SSI,MSI (small급,midium급)|RAMROM등장|운영체제,고급언어활용, 프로세서 속 논리조사 수를 기준으로 세대를 나누기 시작|
|4세대|LSI,VLSI(집적화)|SRAM,DRAM|객체지향언어 사용, PC등장,병렬처리|
|5세대|SoC,VLSI,ULSI,GLSI(집적화에 집적화)|SDRAM,DRAM,flash|폰노이만 구조 추구,멀티코어, 유비쿼터스 컴퓨팅(어디서나 컴퓨터 조작가능)|
  
### 1세대 : 진공관 세대  
작은 백열구와 같은 진공관 소자 사용.  
기억장치로는 자기드럼 사용. 보조기억장치로 종이테이프, 종이카드 사용.  
하드웨어 개발에 주엄. 기계어, 어셈블리어 사용.  
  
과학 기술 계산, 통계 자료 분류 등에 사용.  
  
부피가 커서 큰 공간을 차지함. 잦은 고장. 짧은 수명.  
많은 전력 소모, 열을 시킬 냉각장치를 위한 큰 공간.  
  
### 2세대 : 트랜지스터 세대  
주요소자로 다이오드, 트랜지스터와 같은 반도체 소자 사용.  
기억장치로는 자기코어 사용.  
보조기억장치로 자기드럼, 자기 테이프, 자기 디스크 사용.  
  
포트란, 코볼 등 고급언어 사용.  
컴파일러, 운영체제 등 시스템 소프트웨어 개념 도입.  
  
과학 기술 분야 뿐만 아니라 일반 사무, 생산 관리에도 사용.  
  
진공과 세대의 단점인 공간, 전력 소비 문제 개선.  
신뢰성 향상.  
  
### 3세대 : 집적회로 세대  
반도체 기술의 발달로 집적회로를 이용.  
주요 소자로 소규모 집적회로(Small Scaled IC), 중규모 집적회로(Medium Scaled IC) 사용  
기억장치로도 집적회로 사용.  
보조기억장치로는 자기디스크, 자기테이프 사용.   
출력장치로 프린터 외 비디오 장치를 사용.  
  
소프트웨어 개발하는데 파스칼, LISP 등 구조화된 언어 사용.  
소프트웨어 비중이 점차 커짐.  
캐시메모리도 사용하기 시작.  
  
과학 기술, 일반 사무, 경영 정보처리 등 분야에도 사용.  
  
### 4세대 : 고밀도 집적회로 세대  
집적회로의 집적도 향상.  
주요소자로 대규모 집적회로(Large Scaled IC) 또는  
초대규모 집적회로(Very Large Scaled IC)를 기본 소자로 하여 개발된 컴퓨터  
기억장치로 RAM 등 집적회로 사용.  
보조기억장치로 자기디스크와 광디스크 주로 사용.  
입력장치로 마우스, 스캐너 사용.  
출력장치로 비디오, 오디오 장치 사용.  
  
소프트웨어 개발에 C, Java, 객체지향언어, 시각언어 사용.  
네트워크 기술이 발전하며 Client/Server 개념 도입.  
병렬 처리 기능이 강화됨.  
  
크기도 줄고. 가격도 낮아짐. 개인용 PC 등장.  
  
### 5세대 : 초고밀도 집적회로  
기존 컴퓨터의 한계(폰노이만 아키텍쳐)를 극복하기 위한 차세대 컴퓨터  
비폰노이만형 추구 -> 인공지능  
주요소자로 극초대규모 집적회로(Ultra Large Scaled IC) 사용.  
시스템을 하나의 칩에 집적한 단일 칩 시스템(System On a Chip) 이용.  
입력장치로 음성 입력 마우스, 터피스크린 사용.  
출력장치로 그래픽, 오디오 장치 사용.  
  
수만 개의 마이크로프로세서를 연결한 초병렬 컴퓨터 (고속 연산)  
유비쿼터스 환경.(웨어러블, 바이오 컴퓨터)  
  
# 2. 현대 컴퓨터 발전의 지표  
  
## 폰노이만 아키텍처  
  
### 고정 결선식 프로그램 컴퓨터   
최초의 범용 전자식 디지털 컴퓨터 ENIAC도  
계산기와 마찬가지로 주어진 기능만 수행 가능.  
프로그램 저장, 변경 불가능.  
ENIAC으로 하나의 작업을 하려면 일일이 수작업으로 배선을 변경하거나  
스위치를 조작하고, 계산할 데이터도 천공카드를 사용해 컴퓨터로 옮겨야만했다.  
하드웨어적인 수정이나 조작이 필요했다. 이것이 고정 결선식 프로그램 컴퓨터이다.  
고정 결선식 프로그램 컴퓨터는 스위치 조작, 배선 연결 변경으로 정해진 기능에 대한  
결과를 생성할 수 있다.  
하드웨어적으로 프로그래밍되었기 대문에 주어진 기능을 수정하려면 기계내부의 세부적인 회로 연결 상태를 변경해야 했다.  
이에 대해서 다음과 같은 문젝 있었다.  
  
- 프로그램을 저장, 변경할 수 없기 때문에 주어진 기능만 처리.  
- 주어진 기능을 수정하거나 확대하려면 기계 내부의 세부 구성에 대해 알아야한다.  
소프트웨어 개념이 없었다.  
- 회로 자체 내구성이나 엔지니어 실수로 전체 시스템에 문제가 생길 수 있다.  
  
폰 노이만이 제안한 프로그램을 저장하고 변경할 수 있는 `프로그램 내장식 컴퓨터 모델`.  
컴퓨터 내부에 프로그램과 데이터를 저장하여  
컴퓨터가 필요한 내용을 순서에 따라 인출, 해독 할 수 있다.   
  
`프린스턴 아키텍쳐` 라고도 부른다.  
폰노이만 모델은 앨런 튜링의 유니버셜 기계모델을 구체화한 형태이다.  
  
### 프로그램 내장식 컴퓨터   
프로그램 자체와 프로그램에서 사용하는 데이터를 동일한 형태로  
메모리에 저장할 수 있는 구조. 새로운 프로그램을 만들 수 있고  
기존 프로그램을 수정할 수도 있다.  
  
하드웨어에 대한 전문적인 지식 없이도 원하는 작업을 프로그래밍 할 수 있다.  
**소프트웨어의 개념을 탄생시켰다.**  
  
폰노이만 아키텍쳐는  
명령어를 해석하고 데이터를 처리하는 CPU,  
명령어와 데이터를 저장하는 메모리, 입출력장치로 구성.  
  
**메모리의 특성**  
- 0,1,2,...,n-1 과 같은 순차적인 주소를 가진 워드로 구성  
- 데이터와 명령어를 구분 없이 저장한다.(명령어, 데이터를 동일하게 조작)  
- 메모리에 저장된 워드는 인출될 때 컴퓨터의 상태에 따라 명령어나 데이터로 해석.  
  
CPU----메모리 사이 연결하는 부분을
**폰노이만 병목(von Neumann bottleneck)**이라고한다.  
CPU와 메모리 사이 발생하는 트래픽이 성능에  
큰 영향을 미쳐서 지연 현상이 발생하기 때문이다  
  
---  
  
PC에서 하버드 아키텍쳐 대신 폰노이만 아키텍쳐를 사용하는 이유  
명령어와 데이터를 구분하는거 자체가 일이 될 수 있다.  
대형 컴퓨터에서는 하버드 아키텍쳐를 사용한다.  
  
## 무어의 법칙  
단일 마이크로칩에 포함된 트랜지스터의 수가 1.5년마다 약 2배씩 증가한다는 것을 의미.  
최근 전문가들은 반도체 집적 기술이 이미 한계에 도달했기 때문에  
 무어의 법칙을 유지하기 어려울 것으로 보이며, 이를 무어의 벽이라고 한다.  

# 3. 컴퓨터의 성능

## 성능의 정의
컴퓨터를 고를 때 가장 중요한 것은 속도이다.  
속도라는 단어도 구체적으로 사용자의 관점이 `단체`인지 혹은 `개인` 인지에 따라서 다르다.  
  
**개인 사용자 :**  
**응답시간**이 빠를수록 성능이 좋음  
주어진 작업량을 처리하는데 걸린 시간(시간/개수)이 작을수록 좋다!
  
**단체 사용자 :**  
**처리율**(주어진 시간에 시스템을 얼마나 처리하는가)이 좋을수록 성능이 좋음.  
주어진 시간동안 처리한 양(개수/시간)이 클수록 좋다!  
**처리율**과 **대역폭**은 유사한 개념. 대역폭은 물이 흐르는 통로의 크기로 비유할 수 있다.  

그런데 **응답 시간, 처리율**은 완전히 별개의 요소가 아닌,
일반적으로 하나를 향상하면 다른 것도 성능이 향상된다.

따라서 **응답 시간**을 어떻게하면 단축시킬 수 있을지 살펴본다.

프로그램을 수행하는 데 순수하게 사용된 시간인 **프로그램의 CPU 실행 시간**이 중요하다.
다른 프로그램의 실행시간이 포함되지 않는다.
**성능이 좋다**는 것은 프로그램의 **CPU 실행 시간이 짧다**는 의미이다.

**성능 = 1 / 프로그램의 CPU 실행 시간**

기존의 컴퓨터 M1의 성능을 n배 향상해 만든 컴퓨터를 M2라 할때,
다음과 같이 말할 수 있다.

\- 컴퓨터 M2는 M1보다 성능이 n배 좋다.
\- 컴퓨터 M1에 대해 M2의 성능 향상은 n이다.
\- 컴퓨터 M1에 대한 M2의 성능 비율은 n이다.
\- **성능 비율 n = M2의 성능 / M1의 성능**

성능은 프로그램의 CPU 실행 시간에 반비례함.
-> n = M1의 실행 시간 / M2의 실행 시간

M1과 M2의 실행 시간이 각각 1.0ns, 0.5ns 라고 하면
M2의 성능이 M1보다 두배 좋다고 할 수 있다.


## 암달의 법칙
**암달의 법칙**이 주는 의미:
시스템 일부의 기능을 아무리 향상한다고해도
성능이 향상되지 않은 부분에 의해 시스템의 성능 향상에는 한계가 있다..!

암달의 법칙은 주로 병렬화로 인한 시스템 성능 향상의 한계를 지적하는데 사용된다.

**예를 들어보면 )**
하나의 프로그램이 실행되는데 100시간 걸린다고했을 때,
90시간이 소요되는 곳을 병렬화할 수 있고, 나머지 10시간은 병렬화할 수 없다고 한다.
병렬화에 사용되는 프로세서 수에는 제한이 없다.

90시간이 소요되는 부분을 아무리 병렬화하여 0에 가깝게 만들어도,
나머지 병렬화할 수 없는 부분에 의해 전체 시스템의 성능 향상은 최대 10배이다.

---
이것을 좀 더 구체적으로 살펴보면,

시스템 전체를 1로 뒀을 때,
개선할 수 있는 부분은 f, 나머지 부분을 (1-f)로 가정하자.
성능 향상 전의 컴퓨터를 M1, 향상 후 컴퓨터를 M2라고 하면 시스템의 전체 성능 향상 s는 다음과 같다.
**(s는 M1에 대한 M2의 성능 비율, 바로 위에서는 n이라고 두었다.)**
s = M2의 성능 / M1의 성능 ( = M1의 실행 시간 / M2의 실행 시간)

M2의 실행 시간 =
M1의 실행 시간 * {영향을 받는 부분 / 병렬화 할 수 있는 부분의 성능 향상 크기 + 영향을 받지 않는 부분}
= M1의 실행 시간 * {f / n + (1-f)}

따라서 M1의 일부분을 병렬화하여 만든 M2의 시스템 전체 속도 향상 s는 다음과 같다.

s = 1 / {f / n + (1 - f)}

---

n : 병렬화할 수 있는 부분의 성능 향상 크기
n이 아무리 커지더라도, 즉 시스템 일부를 아무리 병렬화하더라도


# 4. CPU 성능 분석

## 성능에 영향을 미치는 요소


## 성능에 영향을 미치는 요소 분석


# 5. 벤치마크와 성능 척도

## 벤치마크

## MIPS, MFLOPS

