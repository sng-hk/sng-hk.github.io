---
title: "전자계산기구조 - 컴퓨터의 발전, 컴퓨터의 성능"
layout: single
classes: wide
tags : [컴퓨터 아키텍처]
---

# 1. 컴퓨터의 세대별 발전

|컴퓨터의 세대|주요 소자|기억장치|특징|
|---|---|---|---|
0세대|기계적릴레이|금속기어,카드|-|
|1세대|진공관(ex.애니악 최초 컴퓨터)|자기드럼|하드웨어개발에 중점.부피,전력多|
|2세대|트랜지스터|자기코어|고급언어 등장, 운영체제, 컴파일러 등 시스템 소프트웨어 개념 도입|
|3세대|SSI,MSI (small급,midium급)|RAMROM등장|운영체제,고급언어활용, 프로세서 속 논리조사 수를 기준으로 세대를 나누기 시작|
|4세대|LSI,VLSI(집적화)|SRAM,DRAM|객체지향언어 사용, PC등장,병렬처리|
|5세대|SoC,VLSI,ULSI,GLSI(집적화에 집적화)|SDRAM,DRAM,flash|폰노이만 구조 추구,멀티코어, 유비쿼터스 컴퓨팅(어디서나 컴퓨터 조작가능)|
  
### 1세대 : 진공관 세대  
작은 백열구와 같은 진공관 소자 사용.  
기억장치로는 자기드럼 사용. 보조기억장치로 종이테이프, 종이카드 사용.  
하드웨어 개발에 주엄. 기계어, 어셈블리어 사용.  
  
과학 기술 계산, 통계 자료 분류 등에 사용.  
  
부피가 커서 큰 공간을 차지함. 잦은 고장. 짧은 수명.  
많은 전력 소모, 열을 시킬 냉각장치를 위한 큰 공간.  
  
### 2세대 : 트랜지스터 세대  
주요소자로 다이오드, 트랜지스터와 같은 반도체 소자 사용.  
기억장치로는 자기코어 사용.  
보조기억장치로 자기드럼, 자기 테이프, 자기 디스크 사용.  
  
포트란, 코볼 등 고급언어 사용.  
컴파일러, 운영체제 등 시스템 소프트웨어 개념 도입.  
  
과학 기술 분야 뿐만 아니라 일반 사무, 생산 관리에도 사용.  
  
진공과 세대의 단점인 공간, 전력 소비 문제 개선.  
신뢰성 향상.  
  
### 3세대 : 집적회로 세대  
반도체 기술의 발달로 집적회로를 이용.  
주요 소자로 소규모 집적회로(Small Scaled IC), 중규모 집적회로(Medium Scaled IC) 사용  
기억장치로도 집적회로 사용.(RAM, ROM)  
보조기억장치로는 자기디스크, 자기테이프 사용.   
출력장치로 프린터 외 비디오 장치를 사용.  
  
소프트웨어 개발하는데 파스칼, LISP 등 구조화된 언어 사용.  
소프트웨어 비중이 점차 커짐.  
캐시메모리도 사용하기 시작.  
  
과학 기술, 일반 사무, 경영 정보처리 등 분야에도 사용.  
  
### 4세대 : 고밀도 집적회로 세대  
집적회로의 집적도 향상.  
주요소자로 대규모 집적회로(Large Scaled IC) 또는  
초대규모 집적회로(Very Large Scaled IC)를 기본 소자로 하여 개발된 컴퓨터  
기억장치로 RAM 등 집적회로 사용.  
보조기억장치로 자기디스크와 광디스크 주로 사용.  
입력장치로 마우스, 스캐너 사용.  
출력장치로 비디오, 오디오 장치 사용.  
  
소프트웨어 개발에 C, Java, 객체지향언어, 시각언어 사용.  
네트워크 기술이 발전하며 Client/Server 개념 도입.  
병렬 처리 기능이 강화됨.  
  
크기도 줄고. 가격도 낮아짐. 개인용 PC 등장.  
  
### 5세대 : 초고밀도 집적회로  
기존 컴퓨터의 한계(폰노이만 아키텍쳐)를 극복하기 위한 차세대 컴퓨터  
비폰노이만형 추구 -> 인공지능  
주요소자로 극초대규모 집적회로(Ultra Large Scaled IC) 사용.  
시스템을 하나의 칩에 집적한 단일 칩 시스템(System On a Chip) 이용.  
입력장치로 음성 입력 마우스, 터피스크린 사용.  
출력장치로 그래픽, 오디오 장치 사용.  
  
수만 개의 마이크로프로세서를 연결한 초병렬 컴퓨터 (고속 연산)  
유비쿼터스 환경.(웨어러블, 바이오 컴퓨터)  
  
# 2. 현대 컴퓨터 발전의 지표  
  
## 폰노이만 아키텍처  
  
### 고정 결선식 프로그램 컴퓨터   
최초의 범용 전자식 디지털 컴퓨터 ENIAC도  
계산기와 마찬가지로 주어진 기능만 수행 가능.  
프로그램 저장, 변경 불가능.  
ENIAC으로 하나의 작업을 하려면 일일이 수작업으로 배선을 변경하거나  
스위치를 조작하고, 계산할 데이터도 천공카드를 사용해 컴퓨터로 옮겨야만했다.  
하드웨어적인 수정이나 조작이 필요했다. 이것이 고정 결선식 프로그램 컴퓨터이다.  
고정 결선식 프로그램 컴퓨터는 스위치 조작, 배선 연결 변경으로 정해진 기능에 대한  
결과를 생성할 수 있다.  
하드웨어적으로 프로그래밍되었기 대문에 주어진 기능을 수정하려면 기계내부의 세부적인 회로 연결 상태를 변경해야 했다.  
이에 대해서 다음과 같은 문젝 있었다.  
  
- 프로그램을 저장, 변경할 수 없기 때문에 주어진 기능만 처리.  
- 주어진 기능을 수정하거나 확대하려면 기계 내부의 세부 구성에 대해 알아야한다.  
소프트웨어 개념이 없었다.  
- 회로 자체 내구성이나 엔지니어 실수로 전체 시스템에 문제가 생길 수 있다.  
  
폰 노이만이 제안한 프로그램을 저장하고 변경할 수 있는 `프로그램 내장식 컴퓨터 모델`.  
컴퓨터 내부에 프로그램과 데이터를 저장하여  
컴퓨터가 필요한 내용을 순서에 따라 인출, 해독 할 수 있다.   
  
`프린스턴 아키텍쳐` 라고도 부른다.  
폰노이만 모델은 앨런 튜링의 유니버셜 기계모델을 구체화한 형태이다.  
  
### 프로그램 내장식 컴퓨터   
**프로그램 자체와 프로그램에서 사용하는 데이터를 동일한 형태로**  
**메모리에 저장할 수 있는 구조**. 새로운 프로그램을 만들 수 있고  
기존 프로그램을 수정할 수도 있다.  
  
하드웨어에 대한 전문적인 지식 없이도 원하는 작업을 프로그래밍 할 수 있다.  
**소프트웨어의 개념을 탄생시켰다.**  
  
폰노이만 아키텍쳐는  
명령어를 해석하고 데이터를 처리하는 CPU,  
명령어와 데이터를 저장하는 메모리, 입출력장치로 구성.  
  
**메모리의 특성**  
- 0,1,2,...,n-1 과 같은 순차적인 주소를 가진 워드로 구성  
- 데이터와 명령어를 구분 없이 저장한다.(명령어, 데이터를 동일하게 조작)  
- 메모리에 저장된 워드는 인출될 때 컴퓨터의 상태에 따라 명령어나 데이터로 해석.  
  
CPU----메모리 사이 연결하는 부분을
**폰노이만 병목(von Neumann bottleneck)**이라고한다.  
CPU와 메모리 사이 발생하는 트래픽이 성능에  
큰 영향을 미쳐서 지연 현상이 발생하기 때문이다  
  
---  
  
PC에서 하버드 아키텍쳐 대신 폰노이만 아키텍쳐를 사용하는 이유  
명령어와 데이터를 구분하는거 자체가 일이 될 수 있다.  
대형 컴퓨터에서는 하버드 아키텍쳐를 사용한다.  
  
## 무어의 법칙  
단일 마이크로칩에 포함된 트랜지스터의 수가 1.5년마다 약 2배씩 증가한다는 것을 의미.  
최근 전문가들은 반도체 집적 기술이 이미 한계에 도달했기 때문에  
 무어의 법칙을 유지하기 어려울 것으로 보이며, 이를 무어의 벽이라고 한다.  

# 3. 컴퓨터의 성능

## 성능의 정의
컴퓨터를 고를 때 가장 중요한 것은 속도이다.  
속도라는 단어도 구체적으로 사용자의 관점이 `단체`인지 혹은 `개인` 인지에 따라서 다르다.  
  
**개인 사용자 :**  
**응답시간**이 빠를수록 성능이 좋음  
주어진 작업량을 처리하는데 걸린 시간(시간/개수)이 작을수록 좋다!
  
**단체 사용자 :**  
**처리율**(주어진 시간에 시스템을 얼마나 처리하는가)이 좋을수록 성능이 좋음.  
주어진 시간동안 처리한 양(개수/시간)이 클수록 좋다!  
**처리율**과 **대역폭**은 유사한 개념. 대역폭은 물이 흐르는 통로의 크기로 비유할 수 있다.  
  
그런데 **응답 시간, 처리율**은 완전히 별개의 요소가 아닌,  
일반적으로 하나를 향상하면 다른 것도 성능이 향상된다.  
  
따라서 **응답 시간**을 어떻게하면 단축시킬 수 있을지 살펴본다.  
  
프로그램을 수행하는 데 순수하게 사용된 시간인 **프로그램의 CPU 실행 시간**이 중요하다.  
다른 프로그램의 실행시간이 포함되지 않는다.  
**성능이 좋다**는 것은 프로그램의 **CPU 실행 시간이 짧다**는 의미이다.  
  
**성능 = 1 / 프로그램의 CPU 실행 시간**  
  
기존의 컴퓨터 M1의 성능을 n배 향상해 만든 컴퓨터를 M2라 할때,  
다음과 같이 말할 수 있다.  
  
\- 컴퓨터 M2는 M1보다 성능이 n배 좋다.  
\- 컴퓨터 M1에 대해 M2의 성능 향상은 n이다.  
\- 컴퓨터 M1에 대한 M2의 성능 비율은 n이다.  
\- **성능 비율 n = M2의 성능 / M1의 성능**  
  
성능은 프로그램의 CPU 실행 시간에 반비례함.  
-> n = M1의 실행 시간 / M2의 실행 시간  
  
M1과 M2의 실행 시간이 각각 1.0ns, 0.5ns 라고 하면  
M2의 성능이 M1보다 두배 좋다고 할 수 있다.  
  
  
## 암달의 법칙  
**암달의 법칙**이 주는 의미:  
시스템 일부의 기능을 아무리 향상한다고해도  
성능이 향상되지 않은 부분에 의해 시스템의 성능 향상에는 한계가 있다..!  
  
암달의 법칙은 주로 병렬화로 인한 시스템 성능 향상의 한계를 지적하는데 사용된다.  
  
**예를 들어보면 )**  
하나의 프로그램이 실행되는데 100시간 걸린다고했을 때,  
90시간이 소요되는 곳을 병렬화할 수 있고, 나머지 10시간은 병렬화할 수 없다고 한다.  
병렬화에 사용되는 프로세서 수에는 제한이 없다.  
  
90시간이 소요되는 부분을 아무리 병렬화하여 0에 가깝게 만들어도,  
나머지 병렬화할 수 없는 부분에 의해 전체 시스템의 성능 향상은 최대 10배이다.  
  
---  
이것을 좀 더 구체적으로 살펴보면,  
  
시스템 전체를 1로 뒀을 때,  
개선할 수 있는 부분은 f, 나머지 부분을 (1-f)로 가정하자.  
성능 향상 전의 컴퓨터를 M1, 향상 후 컴퓨터를 M2라고 하면 시스템의 전체 성능 향상 s는 다음과 같다.  
**(s는 M1에 대한 M2의 성능 비율, 바로 위에서는 n이라고 두었다.)**  
s = M2의 성능 / M1의 성능 ( = M1의 실행 시간 / M2의 실행 시간)  
  
M2의 실행 시간 =  
M1의 실행 시간 * {영향을 받는 부분 / 병렬화 할 수 있는 부분의 성능 향상 크기 + 영향을 받지 않는 부분}  
= M1의 실행 시간 * {f / n + (1-f)}  
  
따라서 M1의 일부분을 병렬화하여 만든 M2의 시스템 전체 속도 향상 s는 다음과 같다.  
  
s = 1 / {f / n + (1 - f)}  
  
---  
  
n : 병렬화할 수 있는 부분의 성능 향상 크기  
n이 아무리 커지더라도, 즉 시스템 일부를 아무리 병렬화하더라도  
전체 시스템의 성능은 개선되지 않은 부분`1-f` 의 역수 `1/(1-f)` 보다  
더 큰 속도 향상을 이룰 수 없다는 의미이다.  
  
예를 들어,  
전체 시스템에서 실행 시간이 1/3을 차지하는 부분을 병렬화로 처리할 수 있다고 하면,  
전체 시스템의 성능 향상의 최대값은  
  
1/ {(1-1/3)} = 1 / (2/3) = 3/2 (= 1.5)  
  
즉, 이 시스템을 아무리 개선하더라도, 전체 시스템은 1.5배 이상으로  
성능을 향상 할 수 없다.  
  
**결론)**  
**시스템 일부의 기능을 아무리 향상한다고해도**  
**성능이 향상되지 않은 부분에 의해 시스템의 성능 향상에는 한계가 있다..!**  
  
  
# 4. CPU 성능 분석

## 성능에 영향을 미치는 요소  
  
**CPU 실행 시간 = (명령어 개수) \* (평균 CPI) \* (사이클 시간)**  
              **= {(명령어 개수) \* (평균 CPI)} / (클록 속도)**  
  
**1\) **하나의 프로그램에 포함된 명령어 개수(=명렁어 개수/ 프로그램)**  
명령어 집합에 포함된 명령어 종류의 수가 아님.  
일반적으로 하나의 프로그램에 포함된 명령어 개수가 많은면 CPU 실행시간이 증가함.  
  
**아키텍쳐(컴퓨터 구조) or 알고리즘**에 의해 결정된다.  
명령어 개수가 줄면 프로그램 실행 시간도 줄어든다.  
  
**2\)하나의 명령어를 실행하는 데 필요한 클록 사이클 수(=사이클 개수/명령어)**  
CPI(Cycles per Instruction)  
CPI는 명령어마다 다를 수 있기 때문에 모든 명령어에 대한 **평균 CPI**를 기준으로 함.  
  
**컴퓨터의 구현 or 명령어 배합**에 따라 달라짐.  
각 명령어가 실행될 때 필요한 사이클의 수는 알 수 있음.  
명령어 유형별 실행 빈도와 각 명령어에 대한 사이클의 수`(명령어 배합)`로 평균 CPI를 구할 수 있음.  
  
**3\) 한 클록 사이클에 소요되는 시간, 클록 사이클 시간 -> 역수 : **클록 속도 (클록률)**  
  
**아키텍쳐(컴퓨터 구조)** 영향을 어느정도 받음  
주로 **컴퓨터의 구현, 컴퓨터의 실현**에 의해 결정됨.  

---

### 예제 1)
다음과 같은 명령어 배합을 가진 프로그램이 있을 때,
이 프로그램에서 하나의 명령어를 실행하는 데 평균 몇 사이클 소요되는가?

|명령어의 종류| 사용 빈도|사이클|
|---|---|---|
|산술-논리연산 명령어|50%|1|
|적재-저장연산 명령어|30%|2|
|분기연산 명령어|20%|3|

**풀이)**
평균 CPI = 사이클 / 명령어
= sum(사이클) / sum(명령어) 
= {(1 * 5/10) + (2 * 3/10) + (3 * 2/10)} / {5/10 + 3/10 + 2/10}
= {(1 * 5/10) + (2 * 3/10) + (3 * 2/10)} / 1
= 1.7 (사이클/명령어)

---
  
### 예제 2)
컴퓨터 M1, M2가 있고, 각각 세가지 유형의 명령어 그룹이 있는데,  
**명령어 유형별 사용 빈도와 CPI(->평균CPI)**는 다음 표와 같다.  
**클록속도는 각 3GHz, 4GHz** 이다.  
**두 컴퓨터에서 동일한 개수의 동일한 명령어를 포함(->명령어 개수)**  
하는 특정 프로그램을 수행할 때  
**어느 컴퓨터가 더 빨리 실행하는가?(->CPU 실행시간)**  

| |M1| |M2| |
|---|---|---|---|---|
|명령어 종류|사용 빈도|CPI|사용빈도|CPI|
|산술 논리|50%|1|40%|1|
|적재 저장|30%|2|30%|1|
|분기|20%|3|30%|4|
  
**풀이)**  
  
**M1 평균 CPI** = 0.5 * 1 + 0.3 * 2 + 0.2 * 3 = **1.7**  
**M2 평균 CPI** = 0.4 * 1 + 0.3 * 1 + 0.3 * 4 = **1.9**  
  
M1 의 CPU 실행시간 = (n * 1.7) / 3*10**9  
M2 의 CPU 실행시간 = (n * 1.9) / 4*10**9  
  
M1에 대한 M2 의 성능 향상 s  
\= (M1 의 실행 시간) / (M2의 실행 시간)  
\= (n * 1.7 * 4) / (n * 1.9 * 3)  
\= 6.8 / 5.7 = 1.19  
  
따라서 **M2의 성능이 1.19배 더 좋다.**  
  
## 성능에 영향을 미치는 요소 분석  
시스템의 성능은 명령어 개수, 평균 CPI, 클록 속도의 영향을 받는다.  
**그러나 각 요소가 독립적으로 성능을 결정할 수 없다.**  
  
**주의 : 세 요소는 서로 충돌한다.**  
예를 들어, 클록 사이클 시간을 낮추면 평균 CPI가 증가하고,  
평균 CPI를 낮추면, 명령어 개수가 늘어난다.  

성능에 영향을 미치는 요소 사이의 관계
|구분|명령어 개수|평균 CPI|클록 속도|
|---|---|---|---|
|알고리즘|o|-|-|
|(컴퓨터 구조)명령어 집합 구조|o|o|약간|
|컴퓨터 구현|-|o|o|
|컴퓨터 실현|-|-|o|
  
### 명령어 개수  
실행된 명령어 개수는 **알고리즘**과 **아키텍처**에 의해 결정된다.  
  
간결한 알고리즘을 사용하면 프로그램의 크기를 줄일 수 있다.  
  
하나의 명령어가 강력하고 복잡하여 수행하는 일이 많으면(CISC 사용)  
프로그램의 크기를 줄일 수 있다.  
  
`CISC : Complex Instruction Set Computer`  
  
### 평균 CPI  
평균 CPI는 **아키텍처**와 **컴퓨터 구현(컴퓨터 구성)**에 의해 결정된다.  
  
복잡하고 강력한 명령어는 단순한 명령어보다 더 많은 사이클을 필요로 한다.  
따라서 단순한 명령어 집합 구조를 갖는 RISC **아키텍처**를 사용하면  
**평균 CPI**를 낮출 수 있다.  
  
RISC : Reduces Instruction Set Computer  
  
**컴퓨터 구현(구성)** 수준에서 보면 연산을 직렬보다 병렬로 구현할 때,  
사이클의 수가 적다. **파이프 라이닝**같은 고급기술을 사용한다.  
  
### 클록 사이클 시간  
  
사이클 시간은 주로 **컴퓨터 구현(구성)** 과 **컴퓨터 실현**에 의해 결정된다.  
또한 **아키텍처**도 사이클 시간에 다소 영향을 준다.  
**복잡한 명령어**는 일반적으로 **사이클 시간이 길어질 가능성**이 있기 때문이다.  
  
**컴퓨터 구현(컴퓨터 구성)** 수준에서 보자.  
데이터 경로가 짧으면 일반적으로 지연 시간이 짤아지므로  
**사이클 시간**도 짧아진다. 또한 **파이프라이닝**을 이용하면  
한 작업 안에 수행할 작업의 양이 작아지므로 **클록 속도가 빨라진다.**  
  
**컴퓨터 실현** 수준에서 보자.  
최신 반도체 제조 공정은 회로 사이 간격을 더욱 짧게 만든다.  
**동일한 면적에 더 많은 트랜지스터를 집적**하여 **클록 속도를 높일 수 있다.**  
  
# 5. 벤치마크와 성능 척도  
  
## 벤치마크  
  
작업 부하로 선택된 프로그램의 집합을 벤치마크라고 부른다.  
워크스테이션, 서버 등 성능을 평가하는 데 널리 사용되는 벤치마크로,  
SPEC에서 개발한 SPEC 벤치마크 모음이 있다. 프로세서, 그래픽 하드웨어,  
각종 서버 등을 위한 벤치마크 모음을 공개하고 있다.  
  
성능을 평가하는데 쉽게 사용할 수 있는 척도  
CPU 성능 측정 : CPI, 클록속도, MIPS, MFLOPS  
CPU 와 메모리 시스템 등 성능을 종합적 측정 : SPECratio  
기호 조작 및 논리 추론 능력 측정, 인공지능 성능 평가 척도 : KLIPS  
  
그러나, 어떠한 성능 평가 척도도 공급자에 의해 왜곡되어 사용될 수 있음에 유의.  
  
## 성능 평가 척도 : MIPS, MFLOPS  
  
### MIPS  
1초에 수행한 명령어 개수를 100만으로 나눈 값.  
  
**MIPS**  
**\= 명령어 개수 / (실행 시간 * 10^6)**  

```
실행 시간 = CPU 클록 사이클의 수 / 클록 속도

CPI = CPU 클록 사이클의 수 / 명령어 개수

```
  
**MIPS = 명령어 개수 / (CPU 클록 사이클의 수 / 클록 속도 * 10^6)**  
  
**\= 클록 속도 / (CPU 클록 사이클의 수 / 명령어 개수 * 10^6)**  
  
**\= 클록 속도 / (CPI * 10^6)**  
