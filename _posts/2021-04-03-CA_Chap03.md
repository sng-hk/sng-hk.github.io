---
title: "전자계산기구조 - Chap3.명령어 집합"
layout: single
classes: wide
tags : [컴퓨터 아키텍처]
---
  
# 1. 명령어 집합  
  
## 명령어 집합의 의미  
원시 부족 문화 이해 <- 원시 부족 언어를 알아야 함.  
**컴퓨터 이해 <- 프로세서 언어(명령어)를 알아야 함.**  
**명령어는 CPU가 수행할 동작을 2진수 코드로 정의**한 것.  
일반적으로 2진수 코드 대신 연상 부호를 사용한 **어셈블리어 형태**로 표현  
**명령어 집합**은 특정 CPU를 위해 정의된 명령어의 모음을 의미.  
  
## 명령어 집합 구조 ISA  
ISA(Instruction Set Architecture).  
**프로그램과 하드웨어 사이의 인터페이스에 대한 완전한 명세.**  
**ISA는 모든 명령어에 대해 다음과 같은 내용 명시.**  
* 컴퓨터 하드웨어가 **어떤 연산을 수행**할 수 있고, **어떤 데이터가 필요한지** 명시  
* 사용할 수 있는 **데이터의 표현 방식(데이터 형식)** 명시  
* 데이터의 위치에 대한 정보를 알려주는 **주소 지정 방식** 명시  
  
## 명령어 집합 설계  
명령어 집합을 설계하는데에 있어서 **설계 논점 :**  
\- **연산의 종류(어떤 연산을 수행)**  
\- **데이터 형식(사용할 수 있는 데이터 표현 방식), 명령어 형식**  
\- **피연산자 주소 지정 방식(데이터의 위치 정보)**  
  
### 연산의 종류  
**전송 연산**, **처리 연산**, **제어 연산**, **입출력 연산**  
컴퓨터 아키텍처마다 네 종류의 연산이 모두 필요하지만 동일하지는 않다.  
ex. 매우 간단한 컴퓨터의 경우 처리 연산에 있어 덧셈,뺄셈은 있으나  
곱셈, 나눗셈 연산이 없을 수 있다. **3장 4절에서 자세하게 다룸.**
  
### 데이터 형식  
데이터에 가능한 값, 데이터에 실행할 수 있는 명령,  
데이터의 의미, 데이터 값, 데이터 값을 저장하는 방식을 의미.  
대부분 아키텍쳐는 **일반적으로 정수, 실수, 문자 등과 같은 데이터 형식** 지원.  
  
### 명령어 형식  
최소한 연산의 종류를 지정하는 **연산 부호**를 포함.  
연산의 종류에 따라 명령어는 소수의 **피연산자**를 가질 수 있음.  
피연산자는 **데이터의 주소**나 **데이터 자체**.  
  
### 피연산자의 주소 지정 방식  
연산의 종류에 따라 데이터가 필요할 수 있다.  
레지스터, 메모리 등.  
Chap4 에서 다룸.  
  
# 2. 명령어의 특성  
명령어는 다음과 같은 여러가지 요소로 구성  
\- **연산 부호 :**  
덧셈, 뺄셈 등 **연산의 종류** 명시  
\- **피연산자 필드 :**  
일반적으로 데이터 자체보다는 **데이터의 위치** 명시  
\- **모드 비트 :**  
**피연산자의 위치에 대한 명시 방법**  
모드 비트의 상태에 따라 데이터에 대한 **직접 주소** or **간접 주소**  
\- **다음 명령어 주소 필드 :**  
**다음 명령어의 위치**를 나타냄.  
일반적으로 필요하지 않음. **명령어는 순차적으로 실행된다고 가정**하므로,  
**다음 명령어가 다음 주소에 위치**하기 때문.  
  
## 피연산자의 수  
**명령어의 특성**을 규정 짓는다.  
명령어의 기본적인 형식은 산술연산 기반으로 형성 된 것.  
  
### 대부분의 명령어 형식 (3-주소 명령어)  
두 변수 X,Y를 연산한 후 결과값 Z를 생성하는 함수 F를 의미.  
**F는 연산 부호 / X,Y,Z는 피연산자**  
**X,Y,Z는 피연산자 :**  
컴퓨터는 일반적으로 명령어의 피연산자 필드로 명시.  
데이터의 위치 위치를 포함.일반적으로 **주소 필드**라고 함.  
대부분의 명령어는 아래와 같이 3개의 데이터 주소를 갖는데,  
이를 **3-주소 명령어**라고 한다.  
```
Z = F(X,Y)
```
피연산자의 수가 많으면 명령어가 길어져 프로그램이 많은 메모리를 차지.   
**명령어의 길이를 줄이기 위해** 아래와 같은 방법 사용.  
  
### 근원지 피연산자 중 하나를 목적지 피연산자와 겸용 (2-주소 명령어)  
변수 Z를 근원지 겸 목적지 피연산자로 변수 X,Z 만 사용하여  
연산을 수행.  
```
Z = F(X,Z)
```
반복문에서 반복 횟수를 조정하려는 **I=I+1** 과 같은 유형.  
연산 결과를 근원지 피연산자 중 하나에 저장하는 방식.  
명령어의 길이가 짧아지지만, 근원지 피연산자 중 하나(Y)가 파괴.  
  
### 묵시적 피연산자 사용 (1-주소 명령어)  
데이터가 항상 동일한 위치에 있다면 데이터의 위치를 명시할 필요가 없으므로  
피연산자의 수를 하나 더 줄일 수 있다. 이와 같이 주소를 명시할 필요가 없는  
피연산자를 **묵시적 피연산자**라고 한다.  
```
ACC = F(X,ACC)
```
Acc는 누산기를 의미하며 묵시적 피연산자에 해당.  
함수 F()는 누산기를 항상 근원지 겸 목적지 피연산자로 사용.  
명령어는 1개의 명시적인 피연산자(X)만 필요하기 때문에 1-주소 명령어라고 한다.  
  
### 스택 사용 (0-주소 명령어)  
스택 사용하면 데이터의 위치를 명시할 필요가 없다. 예를 들어, 피연산자가 2개이면  
스택의 최상위에 있는 2개의 데이터를 사용하면 된다. 스택을 사용할 때는  
필요한 데이터를 스택의 최상위에서 하나씩 사용하면 되므로 피연산자를 명시할 필요가 없다.  
스택의 최상위 데이터 2개를 읽어 연산한 후 곱셈 결과를 스택의 최상위에 저장한다.  
이와 같이 명시적 피연산자가 필요 없는 명령어를 **0-주소 명령어**라고 한다.  
  
## 명령어의 길이  
**명령어의 특성**을 규정 짓는다.  
명령어는 일반적으로 **연산 부호**와 **피연산자**로 구성  
  
### 고정 길이 명령어 형식  
**명령어의 종류**나 **명령어에 포함된 구성 요소**와 상관 없이  
명령어의 길이가 모두 일정한 명령어 형식.  
**하드웨어를 단순하게 구현 가능.**  
짧은 길이만 필요한 간단한 명령어도 긴 명령어와 동일한 길이로 맞춰야하므로  
**프로그램의 크기가 증가.**  
**RISC구조를 사용하는 컴퓨터**는 모두 고정 길이 명령어 형식  
  
### 가변 길이 명령어 형식  
**명령어의 종류**나 **명령어에 포함된 구성 요소**에 따라  
다양한 길이의 명령어를 사용하는 명령어 형식.  
1개의 피연산자를 가진 명령어가 2개의 피연산자를 가진 명령어보다 짧을 수 있다.  
프로그램의 크기가 작아지고 강력한 명령어를 도입할 수 있으나,  
프로세서를 설계하기가 어렵다.  
구형 컴퓨터의 경우 고가의 메모리를 효율적으로 사용하기 위해 사용.  
  
# 3. CPU의 기본 구성과 가상 명령어 집합  
**명령어 실행 과정**을 분석해보고, **좋은 명령어 집합 구조는 어떤 특성을 갖는지** 알아보자!  
  
## CPU의 기본 구성과 명령어의 실행 순서  
**CPU**는 **제어장치(Control Unit)**, **산술논리장치(ALU,연산장치)**,**레지스터**,**내부 버스**로 구성.  
CPU는 명령어와 데이터 등을 위해 다음과 같은 레지스터 사용.  
\- **PC : 프로그램 계수기**  
Program Counter.  
**다음에 실행할 명령어의 주소**를 보관.  
명령어를 인출한 후에는 명령어의 길이만큼 증가되어 다음 명령어를 가리켜야 한다.  
분기 명령어의 경우 목적지의 주소로 갱신될 수 있다.  
\- **IR : 명령어 레지스터**  
Instruction Register.  
**가장 최근에 인출한 명령어**를 보관.  
\- **ACC : 누산기**  
Accumulator.  
데이터를 일시적으로 보관하는 레지스터.  
\- **MAR : 메모리 주소 레지스터**  
Memory Address Register.  
**프로세서**가 **메모리에 접근**하기 위해 참조하려는  
**데이터의 주소**를 명시하는 버퍼.  
\- **MBR : 메모리 버퍼 레지스터**  
Memory Buffer Register.  
**프로세서**가 **메모리**로부터 읽거나 저장할 **데이터 자체**를  
보관하기 위한 버퍼. 메모리 데이터 레지스터라고도 한다.  
  
### 적재 과정(메모리 -> CPU)  
\[1] **프로세서**는 **데이터가 있는 메모리의 주소**를 **MAR**에 보낸다.  
\[2] **MAR**이 지정하는 메모리 주소에 있는 데이터를 읽어와 **MBR**에 저장.  
\[3] **프로세서**는 **MBR**에 저장된 데이터를 읽는다.  
  
### 저장 과정(CPU -> 메모리)  
\[1] **프로세서**는 데이터를 저장할 메모리의 주소를 **MAR**에 보낸다.  
\[2] **프로세서**는 데이터를 **MBR**에 저장한다.  
\[3] 메모리는 **MAR**이 지정하는 위치에 **MBR**의 내용을 저장한다.  
  
### 명령어 사이클  
CPU가 한 개의 명령어를 실행하는 데 필요한 전체 처리 과정으로서,  
CPU가 프로그램 실행을 시작한 순간부터  
전원을 끄거나 회복 불가능한 오류가 발생하여 중단 될 때까지 반복.  
최소한 다음과 같은 과정을 거쳐야 한다.  
\- **인출 사이클 :**  
CPU가 기억장치로부터 명령어를 읽어오는 단계.  
\- **실행 사이클 :**  
명령어 실행 단계  

### 인출 사이클의 마이크로 연산
```
t0 : MAR <- PC
```
**[첫번째 주기]**  
현재의 PC 내용을 CPU 내부 버스를 통하여 MAR로 전송  
```
t1 : MBR <- M[MAR], PC <- PC + 1
```
**[두번째 주기]**  
그 주소가 지정하는 기억장치(메모리) 위치로부터 읽혀진 명령어가  
데이터 버스를 통하여 MBR로 적재되며, PC의 내용에 1을 더한다  
```
t2 : IR <- MBR
``` 
**[세번째 주기]**  
MBR에 있는 **명령어 코드**가 명령어 레지스터인 IR로 이동  
  
\[예]  
**CPU 클록 = 1GHz (클럭 주기 = 1㎱)**  
**-> 인출 사이클 : 1 ㎱ x 3 = 3 ㎱ 소요**  
  
## 가상 컴퓨터 명령어  
가상 컴퓨터는 매우 간단한 명령어 집합 구조를 사용하므로  
명령어의 실행 과정을 쉽게 분석 가능.  
### 가상 컴퓨터 명령어 형식 및 데이터 형식  
\- **명령어 형식**  
**명령어의 15번 비트**가 **0**이면 4개의 비트가 연산부호이고,  
15번 비트가 **1**이면 16비트모두가 연산부호.  
\- **데이터 형식**  
정수 데이터 형식에서 **15번 비트**는 **부호비트**로서  
**0**이면 **양수**, **1**이면 **음수**  
  
## 좋은 명령어 집합 구조  
\- **일관성**  
일부 명령어의 구조만 알더라도 나머지 명령어의 구조를 예측 가능.  
산술연산, 명령어 등 예측 가능해야함.  
\- **직교성**  
**명령어의 구성 요소**가 **연산 부호**와 **독립적**으로 결정.  
\- **적절성**  
본질적이지 않거나 기능과 관계없는 부분은 최소화.  
**시스템 필수 요구 조건을 만족**하며, 본질적이어야함.  
\- **일반성**  
하나의 기능을 다양한 목적으로 사용할 수 있는 것을 의미.  
일반성을 만족하려면 **완전성**과 **확장성**이 요구된다.  
**완전성**  
ex. 정수에 대해서 나눗셈 가능하면, 부동소수점 수에 대해서도 가능해야함  
**확장성**  
ex. 64개 명령어를 가진 프로세서에 6비트 공간만 제공하면, 동일한 아키텍처의  
신규 모델에 새로운 명령어 추가 불가능, 이는 확장성 위배  
  
# 4. 연산  
컴퓨터의 4대 기능(입력,출력,처리,저장)을 수행하기 위해  
다양한 종류의 연산을 수행하는 명령어을 제공해야 한다.  
**연산의 종류**를 알아보고, 비순차적인 실행을 위한 **제어 연산**인  
**분기 명령**과 ***프로시저**의 동작 메커니즘에 대해 알아보자.  
  
## 연산의 종류  
컴퓨터는 크게 전송 연산, 처리 연산, **제어 연산**, 입출력 연산 제공.  
\- **전송 연산 :**  
적재 및 저장 연산  
**적재 : 메모리 -> CPU**  
**저장 : CPU -> 메모리**  
\- **처리 연산 :**  
산술 연산, 논리 연산, 변환 연산(데이터 형식 변환)  
\- **제어 연산 :**  
**분기 명령(무조건 분기, 조건 분기), 프로시저 호출 및 복귀**  
\- **입출력 연산 :**  
가상 컴퓨터에는 따로 없다.(명령어가 간단하기 때문)  

## 분기 명령

## 프로시저의 호출과 복귀

# 5. 명령어와 CPU 기억장치

##