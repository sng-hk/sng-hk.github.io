---
title: "전자계산기구조 - Chap3.명령어 집합"
layout: single
classes: wide
tags : [컴퓨터 아키텍처]
---
  
# 1. 명령어 집합  
  
## 명령어 집합의 의미  
원시 부족 문화 이해 <- 원시 부족 언어를 알아야 함.  
**컴퓨터 이해 <- 프로세서 언어(명령어)를 알아야 함.**  
**명령어는 CPU가 수행할 동작을 2진수 코드로 정의**한 것.  
일반적으로 2진수 코드 대신 연상 부호를 사용한 **어셈블리어 형태**로 표현  
**명령어 집합**은 특정 CPU를 위해 정의된 명령어의 모음을 의미.  
  
## 명령어 집합 구조 ISA  
ISA(Instruction Set Architecture).  
**프로그램과 하드웨어 사이의 인터페이스에 대한 완전한 명세.**  
**ISA는 모든 명령어에 대해 다음과 같은 내용 명시.**  
* 컴퓨터 하드웨어가 **어떤 연산을 수행**할 수 있고, **어떤 데이터가 필요한지** 명시  
* 사용할 수 있는 **데이터의 표현 방식(데이터 형식)** 명시  
* 데이터의 위치에 대한 정보를 알려주는 **주소 지정 방식** 명시  
  
## 명령어 집합 설계  
명령어 집합을 설계하는데에 있어서 **설계 논점 :**  
\- **연산의 종류(어떤 연산을 수행)**  
\- **데이터 형식(사용할 수 있는 데이터 표현 방식), 명령어 형식**  
\- **피연산자 주소 지정 방식(데이터의 위치 정보)**  
  
### 연산의 종류  
**전송 연산**, **처리 연산**, **제어 연산**, **입출력 연산**  
컴퓨터 아키텍처마다 네 종류의 연산이 모두 필요하지만 동일하지는 않다.  
ex. 매우 간단한 컴퓨터의 경우 처리 연산에 있어 덧셈,뺄셈은 있으나  
곱셈, 나눗셈 연산이 없을 수 있다. **3장 4절에서 자세하게 다룸.**
  
### 데이터 형식  
데이터에 가능한 값, 데이터에 실행할 수 있는 명령,  
데이터의 의미, 데이터 값, 데이터 값을 저장하는 방식을 의미.  
대부분 아키텍쳐는 **일반적으로 정수, 실수, 문자 등과 같은 데이터 형식** 지원.  
  
### 명령어 형식  
최소한 연산의 종류를 지정하는 **연산 부호**를 포함.  
연산의 종류에 따라 명령어는 소수의 **피연산자**를 가질 수 있음.  
피연산자는 **데이터의 주소**나 **데이터 자체**.  
  
### 피연산자의 주소 지정 방식  
연산의 종류에 따라 데이터가 필요할 수 있다.  
레지스터, 메모리 등.  
Chap4 에서 다룸.  
  
# 2. 명령어의 특성  
명령어는 다음과 같은 여러가지 요소로 구성  
\- **연산 부호 :**  
덧셈, 뺄셈 등 **연산의 종류** 명시  
\- **피연산자 필드 :**  
일반적으로 데이터 자체보다는 **데이터의 위치** 명시  
\- **모드 비트 :**  
**피연산자의 위치에 대한 명시 방법**  
모드 비트의 상태에 따라 데이터에 대한 **직접 주소** or **간접 주소**  
\- **다음 명령어 주소 필드 :**  
**다음 명령어의 위치**를 나타냄.  
일반적으로 필요하지 않음. **명령어는 순차적으로 실행된다고 가정**하므로,  
**다음 명령어가 다음 주소에 위치**하기 때문.  
  
## 피연산자의 수  
**명령어의 특성**을 규정 짓는다.  
명령어의 기본적인 형식은 산술연산 기반으로 형성 된 것.  
  
### 대부분의 명령어 형식 (3-주소 명령어)  
두 변수 X,Y를 연산한 후 결과값 Z를 생성하는 함수 F를 의미.  
**F는 연산 부호 / X,Y,Z는 피연산자**  
**X,Y,Z는 피연산자 :**  
컴퓨터는 일반적으로 명령어의 피연산자 필드로 명시.  
데이터의 위치 위치를 포함.일반적으로 **주소 필드**라고 함.  
대부분의 명령어는 아래와 같이 3개의 데이터 주소를 갖는데,  
이를 **3-주소 명령어**라고 한다.  
```
Z = F(X,Y)
```
피연산자의 수가 많으면 명령어가 길어져 프로그램이 많은 메모리를 차지.   
**명령어의 길이를 줄이기 위해** 아래와 같은 방법 사용.  
  
### 근원지 피연산자 중 하나를 목적지 피연산자와 겸용 (2-주소 명령어)  
변수 Z를 근원지 겸 목적지 피연산자로 변수 X,Z 만 사용하여  
연산을 수행.  
```
Z = F(X,Z)
```
반복문에서 반복 횟수를 조정하려는 **I=I+1** 과 같은 유형.  
연산 결과를 근원지 피연산자 중 하나에 저장하는 방식.  
명령어의 길이가 짧아지지만, 근원지 피연산자 중 하나(Y)가 파괴.  
  
### 묵시적 피연산자 사용 (1-주소 명령어)  
데이터가 항상 동일한 위치에 있다면 데이터의 위치를 명시할 필요가 없으므로  
피연산자의 수를 하나 더 줄일 수 있다. 이와 같이 주소를 명시할 필요가 없는  
피연산자를 **묵시적 피연산자**라고 한다.  
```
ACC = F(X,ACC)
```
Acc는 누산기를 의미하며 묵시적 피연산자에 해당.  
함수 F()는 누산기를 항상 근원지 겸 목적지 피연산자로 사용.  
명령어는 1개의 명시적인 피연산자(X)만 필요하기 때문에 1-주소 명령어라고 한다.  
  
### 스택 사용 (0-주소 명령어)  
스택 사용하면 데이터의 위치를 명시할 필요가 없다. 예를 들어, 피연산자가 2개이면  
스택의 최상위에 있는 2개의 데이터를 사용하면 된다. 스택을 사용할 때는  
필요한 데이터를 스택의 최상위에서 하나씩 사용하면 되므로 피연산자를 명시할 필요가 없다.  
스택의 최상위 데이터 2개를 읽어 연산한 후 곱셈 결과를 스택의 최상위에 저장한다.  
이와 같이 명시적 피연산자가 필요 없는 명령어를 **0-주소 명령어**라고 한다.  
  
## 명령어의 길이  
**명령어의 특성**을 규정 짓는다.  
명령어는 일반적으로 **연산 부호**와 **피연산자**로 구성  
  
### 고정 길이 명령어 형식  
**명령어의 종류**나 **명령어에 포함된 구성 요소**와 상관 없이  
명령어의 길이가 모두 일정한 명령어 형식.  
**하드웨어를 단순하게 구현 가능.**  
짧은 길이만 필요한 간단한 명령어도 긴 명령어와 동일한 길이로 맞춰야하므로  
**프로그램의 크기가 증가.**  
**RISC구조를 사용하는 컴퓨터**는 모두 고정 길이 명령어 형식  
  
### 가변 길이 명령어 형식  
**명령어의 종류**나 **명령어에 포함된 구성 요소**에 따라  
다양한 길이의 명령어를 사용하는 명령어 형식.  
1개의 피연산자를 가진 명령어가 2개의 피연산자를 가진 명령어보다 짧을 수 있다.  
프로그램의 크기가 작아지고 강력한 명령어를 도입할 수 있으나,  
프로세서를 설계하기가 어렵다.  
구형 컴퓨터의 경우 고가의 메모리를 효율적으로 사용하기 위해 사용.  
  
# 3. CPU의 기본 구성과 가상 명령어 집합  
**명령어 실행 과정**을 분석해보고, **좋은 명령어 집합 구조는 어떤 특성을 갖는지** 알아보자!  
  
## CPU의 기본 구성과 명령어의 실행 순서  
**CPU**는 **제어장치(Control Unit)**, **산술논리장치(ALU,연산장치)**,**레지스터**,**내부 버스**로 구성.  
CPU는 명령어와 데이터 등을 위해 다음과 같은 레지스터 사용.  
\- **PC : 프로그램 계수기**  
Program Counter.  
**다음에 실행할 명령어의 주소**를 보관.  
명령어를 인출한 후에는 명령어의 길이만큼 증가되어 다음 명령어를 가리켜야 한다.  
분기 명령어의 경우 목적지의 주소로 갱신될 수 있다.  
\- **IR : 명령어 레지스터**  
Instruction Register.  
**가장 최근에 인출한 명령어**를 보관.  
\- **ACC : 누산기**  
Accumulator.  
데이터를 일시적으로 보관하는 레지스터.  
\- **MAR : 메모리 주소 레지스터**  
Memory Address Register.  
**프로세서**가 **메모리에 접근**하기 위해 참조하려는  
**데이터의 주소**를 명시하는 버퍼.  
\- **MBR : 메모리 버퍼 레지스터**  
Memory Buffer Register.  
**프로세서**가 **메모리**로부터 읽거나 저장할 **데이터 자체**를  
보관하기 위한 버퍼. 메모리 데이터 레지스터라고도 한다.  
  
### 적재 과정(메모리 -> CPU)  
\[1] **프로세서**는 **데이터가 있는 메모리의 주소**를 **MAR**에 보낸다.  
\[2] **MAR**이 지정하는 메모리 주소에 있는 데이터를 읽어와 **MBR**에 저장.  
\[3] **프로세서**는 **MBR**에 저장된 데이터를 읽는다.  
  
### 저장 과정(CPU -> 메모리)  
\[1] **프로세서**는 데이터를 저장할 메모리의 주소를 **MAR**에 보낸다.  
\[2] **프로세서**는 데이터를 **MBR**에 저장한다.  
\[3] 메모리는 **MAR**이 지정하는 위치에 **MBR**의 내용을 저장한다.  
  
### 명령어 사이클  
CPU가 한 개의 명령어를 실행하는 데 필요한 전체 처리 과정으로서,  
CPU가 프로그램 실행을 시작한 순간부터  
전원을 끄거나 회복 불가능한 오류가 발생하여 중단 될 때까지 반복.  
최소한 다음과 같은 과정을 거쳐야 한다.  
\- **인출 사이클 :**  
CPU가 기억장치로부터 명령어를 읽어오는 단계.  
\- **실행 사이클 :**  
명령어 실행 단계  

### 인출 사이클의 마이크로 연산
```
t0 : MAR <- PC
```
**[첫번째 주기]**  
현재의 PC 내용을 CPU 내부 버스를 통하여 MAR로 전송  
```
t1 : MBR <- M[MAR], PC <- PC + 1
```
**[두번째 주기]**  
그 주소가 지정하는 기억장치(메모리) 위치로부터 읽혀진 명령어가  
데이터 버스를 통하여 MBR로 적재되며, PC의 내용에 1을 더한다  
```
t2 : IR <- MBR
``` 
**[세번째 주기]**  
MBR에 있는 **명령어 코드**가 명령어 레지스터인 IR로 이동  
  
\[예]  
**CPU 클록 = 1GHz (클럭 주기 = 1㎱)**  
**-> 인출 사이클 : 1 ㎱ x 3 = 3 ㎱ 소요**  
  
## 가상 컴퓨터 명령어  
가상 컴퓨터는 매우 간단한 명령어 집합 구조를 사용하므로  
명령어의 실행 과정을 쉽게 분석 가능.  
### 가상 컴퓨터 명령어 형식 및 데이터 형식  
\- **명령어 형식**      
**명령어의 15번 비트**가 **0**이면 4개의 비트가 연산부호이고,  
15번 비트가 **1**이면 16비트모두가 연산부호.  
\- **데이터 형식**  
정수 데이터 형식에서 **15번 비트**는 **부호비트**로서  
**0**이면 **양수**, **1**이면 **음수**  
  
## 좋은 명령어 집합 구조  
\- **일관성**  
일부 명령어의 구조만 알더라도 나머지 명령어의 구조를 예측 가능.  
산술연산, 명령어 등 예측 가능해야함.  
\- **직교성**  
**명령어의 구성 요소**가 **연산 부호**와 **독립적**으로 결정.  
\- **적절성**  
본질적이지 않거나 기능과 관계없는 부분은 최소화.  
**시스템 필수 요구 조건을 만족**하며, 본질적이어야함.  
\- **일반성**  
하나의 기능을 다양한 목적으로 사용할 수 있는 것을 의미.  
일반성을 만족하려면 **완전성**과 **확장성**이 요구된다.  
**완전성**  
ex. 정수에 대해서 나눗셈 가능하면, 부동소수점 수에 대해서도 가능해야함  
**확장성**  
ex. 64개 명령어를 가진 프로세서에 6비트 공간만 제공하면, 동일한 아키텍처의  
신규 모델에 새로운 명령어 추가 불가능, 이는 확장성 위배  
  
# 4. 연산  
컴퓨터의 4대 기능(입력,출력,처리,저장)을 수행하기 위해  
다양한 종류의 연산을 수행하는 명령어을 제공해야 한다.  
**연산의 종류**를 알아보고, 비순차적인 실행을 위한 **제어 연산**인  
**분기 명령**과 ***프로시저**의 동작 메커니즘에 대해 알아보자.  
  
## 연산의 종류  
컴퓨터는 크게 전송 연산, 처리 연산, **제어 연산**, 입출력 연산 제공.  
\- **전송 연산 :**  
CPU - 메모리 사이에서 데이터를 교환하는 연산.  
적재 및 저장 연산.  
**적재 : 메모리 -> CPU**  
**저장 : CPU -> 메모리**  
\- **처리 연산 :**  
산술 연산, 논리 연산, 변환 연산(데이터 형식 변환)  
\- **제어 연산 :**  
**CPU의 제어장치**가 프로그램의 실행 순서를 제어하는 연산.
프로그램에서 명령어의 순서가 항상 순차적이지 않다.
아키텍처 자체가 제어 기능으을 수행하는 명령어를 지원함으로써
프로그래밍 언어에 융통성과 일반성을 제공하기 때문이다.
예를 들어 고급언어에서는 명령어를 비순차적을 실행하기 위해 반복문, 조건문, 프로시저 등을 사용할 수 있다.
**분기 명령(무조건 분기, 조건 분기), 프로시저 호출 및 복귀**  
\- **입출력 연산 :**  
가상 컴퓨터에는 따로 없다.(명령어가 간단하기 때문)  
  
## 분기 명령  
\- **체인 방식(Old)**  
명령어가 다음 명령어의 위치를 명시하는 방식.  
예전에 드럼(기억장치)을 썼을  
다음에 수행할 위치를 현재 명령어를 통해 직접적으로 알 수 있지만,  
명령어의 길이가 길어져 오늘날에는 사용하지 않지만 마이크로 프로그래밍에서는 사용하기도 한다.  
\- **분기 방식(New)**  
명령어에 다음 명령어의 위치를 명시하지 않고,  
실행될 다음 명령어는 기본적으로 현재 명령어의 다음 위치에 있다고 간주하는 방식.  
명령어의 길이가 짧고 다음 명령어를 예측할 수 있기 때문에 구현하기가 용이하다.  
오늘날 컴퓨터는 분기 방식을 채택하여 제어 연산을 지원한다.  
  
### 조건 분기 방식  
  
**1\)검사 조건 생성**  
**2\)조건 판단 및 위치 선택**  
```
if(x>y) // x와 y값에 따라서 bigger로 갈지 smaller로 갈지 정함.
then goto BIGGER
else goto SMALLER
```
이러한 **조건 생성**은 두가지로 분류될 수 있다.  
\- **묵시적으로 조건을 생성할 경우 :**  
산술연산 및 논리연산이 실행될 때마다  
생성되는 부수 효과를 조건으로 사용한다.  
뺄셈 결과 값 자체가 아니라  
**뺄셈의 부수적 결과인 양,음,0 을 다음 명령어에서 검사할 조건**으로 사용할 수 있다.  
\- **명시적으로 조건을 생성할 경우 :**  
CMP, TST와 같은 특별한 명령어를 사용하여  
테스트를 수행한 결과를 검사할 조건으로 사용한다.  
(나중에 알아본다.)  
  
### 플래그 레지스터  
어떤 방법으로 비교하더라도 생성된 조건을 사용하려면 저장해둬야 한다.  
대부분 플래그 레지스터를 사용하여 저장.  
* **C(Carry) :**  
연산결과에 올림수가 있으면 1, 없으면 0으로 설정된다.  
* **V(Overflow) :**  
연산결과에 따라서 오버플로우가 있으면 1, 없으면 0으로 설정.  
* **S(Sign):**  
연산결과가 음수면 1, 양수면 0으로 설정.  
* **Z :**  
연산결과가 0이면 1, 0이 아니면 0으로 설정.  
  
### 무조건 분기 방식  
조건에 관계없이 분기.  
**가상 컴퓨터의 JMP 명령어**와 같이 PC의 내용만 변경하면 되기 때문에 간단.  
  
## 프로시저의 호출과 복귀  
  
### 프로시저의 호출(cal proc)  
* **인출 사이클 :**  
CPU가 기억장치로부터 명령어를 읽어오는 단계.  
```
IR <- Memory[PC]; PC <- PC + Δ(Δ는 명령어의 길이)
```
**메모리에 PC번지에 담긴 명령어를 IR에 담고, PC는 다음에 실행할 명령어를 가르키도록 함.**  
* **실행 사이클 :**  
```
TOS <- PC; PC <- proc
```
**명령어를 실행하는 단계. 즉, 함수를 호출하는 단계.**  
**TOS(Top of Stack)**는 스택의 최상위 부분을 의미.  
실행 사이클의 첫번째 작업은 다음에 실행할 명령어 주소 값인 PC, 즉 복귀 주소를 스택에 넣는 것.  
**이후 PC에 proc의 주소를 저장.**  
**이후부터는 호출된 프로시저 proc에 있는 명령어를 인출.**  
### 프로시저의 복귀(ret)  
복귀 주소는 스택의 최상위에 있기 때문에 PC의 내용을 스택의 최상위 값으로 변경.  
* **인출 사이클 :**  
```
IR <- M[PC]; PC <- PC + Δ(Δ는 명령어의 길이)
```
**메모리에 PC번지에 담긴 명령어를 IR에 담고, PC는 다음에 실행할 명령어를 가르키도록 함.**  
프로시저 복귀 명령에 대한 인출 사이클도 다른 명령어와 동일.  
* **실행 사이클 :**  
```
PC <- TOS
```
**명령어를 실행하는 단계. 즉, 복귀하는 단계.**  
스택의 최상위에 있는 내용을 PC로 끄집어낸다. 스택의 최상위에는  
호출한 프로그램의 **cal proc** 다음 명령어의 주소인 복귀 주소가 있다.  
이 복귀 주소를 가져옴으로써 **cal proc** 뒤에 있는 명령어를 인출할 것이다.  
실제로는 복잡할 수 있다.  
  
# 5. 명령어와 CPU 기억장치  
  
## 메모리-메모리 컴퓨터  
**CPU 내부에 기억장치(레지스터)가 없는 가상의 컴퓨터.**  
모든 데이터가 CPU 내부에 기억되지 않고 메모리에서 CPU를 경유하여 메모리로 전송.  
데이터가 필요한 경우 명령어의 피연산자 필드에 메모리 전체 주소를 명시.  
**폰노이만 병목에서 발생하는 트래픽에 부담.**  
  
## CPU에 기억장치가 있다면  
**폰노이만 병목에서 발생하는 트래픽을**
**다음과 같은 이유로 크게 감소시킬 수 있다.**
\- **데이터 트래픽 감소 :**  
반복적으로 사용되는 피연산자를 CPU 내부의 기억장치에 보관.  
메모리를 다시 참조할 필요성 제거.  
\- **명령어 트래픽 감소 :**  
대용량 메모리를 위한 긴 주소 대신에 소규모 기억장치의 짧은 주소로 피연산자를 명시  
피연산자 필드가 짧아지면 명령어의 길이가 축소  