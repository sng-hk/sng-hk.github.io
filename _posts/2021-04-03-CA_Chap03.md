---
title: "전자계산기구조 - Chap3.명령어 집합"
layout: single
classes: wide
tags : [컴퓨터 아키텍처]
---

# 1. 명령어 집합

## 명령어 집합의 의미
원시 부족 문화 이해 <- 원시 부족 언어를 알아야 함.
**컴퓨터 이해 <- 프로세서 언어(명령어)를 알아야 함.**
**명령어는 CPU가 수행할 동작을 2진수 코드로 정의**한 것.
일반적으로 2진수 코드 대신 연상 부호를 사용한 **어셈블리어 형태**로 표현
**명령어 집합**은 특정 CPU를 위해 정의된 명령어의 모음을 의미.

## 명령어 집합 구조 ISA
ISA(Instruction Set Architecture).
**프로그램과 하드웨어 사이의 인터페이스에 대한 완전한 명세.**
**ISA는 모든 명령어에 대해 다음과 같은 내용 명시.**
* 컴퓨터 하드웨어가 **어떤 연산을 수행**할 수 있고, **어떤 데이터가 필요한지** 명시
* 사용할 수 있는 **데이터의 표현 방식(데이터 형식)** 명시
* 데이터의 위치에 대한 정보를 알려주는 **주소 지정 방식** 명시

## 명령어 집합 설계
명령어 집합을 설계하는데에 있어서 **설계 논점 :**
\- **연산의 종류(어떤 연산을 수행)**
\- **데이터 형식(사용할 수 있는 데이터 표현 방식), 명령어 형식**
\- **피연산자 주소 지정 방식(데이터의 위치 정보)**

### 연산의 종류
- **전송 연산**
- **처리 연산**
- **제어 연산**
- **입출력 연산**
컴퓨터 아키텍처마다 네 종류의 연산이 모두 필요하지만 동일하지는 않다.
ex. 매우 간단한 컴퓨터의 경우 처리 연산에 있어 덧셈,뺄셈은 있으나
곱셈, 나눗셈 연산이 없을 수 있다.

### 데이터 형식
데이터에 가능한 값, 데이터에 실행할 수 있는 명령,
데이터의 의미, 데이터 값, 데이터 값을 저장하는 방식을 의미.
대부분 아키텍쳐는 **일반적으로 정수, 실수, 문자 등과 같은 데이터 형식** 지원.

### 명령어 형식
최소한 연산의 종류를 지정하는 **연산 부호**를 포함.
연산의 종류에 따라 명령어는 소수의 **피연산자**를 가질 수 있음.
피연산자는 **데이터의 주소**나 **데이터 자체**.

### 피연산자의 주소 지정 방식
연산의 종류에 따라 데이터가 필요할 수 있다.
레지스터, 메모리 등.
Chap4 에서 다룸.

# 2. 명령어의 특성
명령어는 다음과 같은 여러가지 요소로 구성
\- **연산 부호 :**
덧셈, 뺄셈 등 **연산의 종류** 명시
\- **피연산자 필드 :**
일반적으로 데이터 자체보다는 **데이터의 위치** 명시
\- **모드 비트 :**
**피연산자의 위치에 대한 명시 방법**
모드 비트의 상태에 따라 데이터에 대한 **직접 주소** or **간접 주소**
\- **다음 명령어 주소 필드 :**
**다음 명령어의 위치**를 나타냄.
일반적으로 필요하지 않음. **명령어는 순차적으로 실행된다고 가정**하므로,
**다음 명령어가 다음 주소에 위치**하기 때문.

## 피연산자의 수
**명령어의 특성**을 규정 짓는다.
명령어의 기본적인 형식은 산술연산 기반으로 형성 된 것.

### 대부분의 명령어 형식 (3-주소 명령어)
두 변수 X,Y를 연산한 후 결과값 Z를 생성하는 함수 F를 의미.
**F는 연산 부호 / X,Y,Z는 피연산자**
**X,Y,Z는 피연산자 :**
컴퓨터는 일반적으로 명령어의 피연산자 필드로 명시.
데이터의 위치 위치를 포함.일반적으로 **주소 필드**라고 함.
대부분의 명령어는 아래와 같이 3개의 데이터 주소를 갖는데,
이를 **3-주소 명령어**라고 한다.
```
Z = F(X,Y)
```
피연산자의 수가 많으면 명령어가 길어져 프로그램이 많은 메모리를 차지. 
**명령어의 길이를 줄이기 위해** 아래와 같은 방법 사용.

### 근원지 피연산자 중 하나를 목적지 피연산자와 겸용 (2-주소 명령어)
변수 Z를 근원지 겸 목적지 피연산자로 변수 X,Z 만 사용하여
연산을 수행.
```
Z = F(X,Z)
```
반복문에서 반복 횟수를 조정하려는 **I=I+1** 과 같은 유형.
연산 결과를 근원지 피연산자 중 하나에 저장하는 방식.
명령어의 길이가 짧아지지만, 근원지 피연산자 중 하나(Y)가 파괴.

### 묵시적 피연산자 사용 (1-주소 명령어)
데이터가 항상 동일한 위치에 있다면 데이터의 위치를 명시할 필요가 없으므로
피연산자의 수를 하나 더 줄일 수 있다. 이와 같이 주소를 명시할 필요가 없는
피연산자를 **묵시적 피연산자**라고 한다.
```
ACC = F(X,ACC)
```
Acc는 누산기를 의미하며 묵시적 피연산자에 해당.
함수 F()는 누산기를 항상 근원지 겸 목적지 피연산자로 사용.
명령어는 1개의 명시적인 피연산자(X)만 필요하기 때문에 1-주소 명령어라고 한다.

### 스택 사용 (0-주소 명령어)
스택 사용하면 데이터의 위치를 명시할 필요가 없다. 예를 들어, 피연산자가 2개이면
스택의 최상위에 있는 2개의 데이터를 사용하면 된다. 스택을 사용할 때는
필요한 데이터를 스택의 최상위에서 하나씩 사용하면 되므로 피연산자를 명시할 필요가 없다.
스택의 최상위 데이터 2개를 읽어 연산한 후 곱셈 결과를 스택의 최상위에 저장한다.
이와 같이 명시적 피연산자가 필요 없는 명령어를 **0-주소 명령어**라고 한다.

## 명령어의 길이
**명령어의 특성**을 규정 짓는다.
**명령어는 일반적으로 연산 부호와 피연산자로 구성**

### 고정 길이 명령어 형식
**명령어의 종류**나 **명령어에 포함된 구성 요소**와 상관 없이
명령어의 길이가 모두 일정한 명령어 형식.
**하드웨어를 단순하게 구현 가능.**
짧은 길이만 필요한 간단한 명령어도 긴 명령어와 동일한 길이로 맞춰야하므로
**프로그램의 크기가 증가.**
**RISC구조를 사용하는 컴퓨터**는 모두 고정 길이 명령어 형식

### 가변 길이 명령어 형식
**명령어의 종류**나 **명령어에 포함된 구성 요소**에 따라
다양한 길이의 명령어를 사용하는 명령어 형식.


# 3. CPU의 기본 구성과 가상 명령어 집합

## CPU의 기본 구성과 명령어의 실행 순서

### 적재 과정

### 저장 과정

### 명령어 사이클

## 좋은 명령어 집합 구조

# 4. 연산

## 연산의 종류

## 분기 명령

## 프로시저의 호출과 복귀

# 5. 명령어와 CPU 기억장치

##